#+BEGIN_LATEX
\begin{titlepage}

  \centering
  {\Large\bfseries Big Data Assignment 1 \par}
  \vspace{0.5cm}

  {\large CRGMAT002 GRDDAN017 KFWJOR001 MRCGAB004 WHLJOS001\par}
  \vspace{0.5cm}

  {\large March 1, 2024\par}

  \vspace{2cm}
  \includegraphics[width=0.4\textwidth]{mongo.png}
  \includegraphics[width=0.4\textwidth]{uct.png}
\end{titlepage}
\tableofcontents
#+END_LATEX
#+LATEX_HEADER: \hypersetup{colorlinks=true, allcolors=blue} \usepackage{titlesec} \usepackage{geometry} \geometry{margin=1.2in} \usepackage{minted} \newcommand{\sectionbreak}{\clearpage} \usepackage{graphicx} \usepackage{changepage} \usepackage{inconsolata}

#+OPTIONS: toc:nil
\pagebreak

* Find or Create a Suitable Data Set
** Data Set Explanation
Link to the dataset: https://github.com/zygmuntz/goodbooks-10k\\
\linebreak
The dataset includes data from an online book review platform (https://goodreads.com/). It includes information about the books, users, book tags, and book rating scores. The dataset initially contained multiple csv files. This dataset was chosen as its ideal for a MongoDB database due to its semi-structured nature and nested data, which is particularly useful for storing ratings and book tags. \\
\linebreak
*Dataset Content*:
- *books.csv*: Each entry represents a book with a unique ~book_id~. There are multiple data fields for a book:
  - *~book_id~, ~goodreads_book_id~, ~best_book_id~, ~work_id~*: Unique id’s representing a book, each with a different purpose. We only used ~book_id~ and ~goodreads_book_id~ as they’re used to link books to user ~ratings~ and user ~to_read~ lists.
  - *~ratings_1~, ~ratings_2~, …*: Number of user ratings by rating value. eg. ~ratings_1~ represents the number of 1-star ratings given to that book.
  - The rest of the fields are self-explanatory but include info relating to authors, title, release date, and isbn number.
- *ratings.csv*: Each entry is a ~user_id~ to ~book_id~ mapping with a rating.
  - *~book_tags.csv~*: Each entry is a ~book_id~ to ~tag_id~ mapping.
  - *~tags.csv~*: Each entry is a tag_id to ~tag_name~ mapping.
  - *~to_read.csv~* : Each entry is a ~user_id~ to ~goodreads_book_id~ mapping which represents a user adding a book to their ~to_read~ list.
** Data Pre-Processing
The data was processed such that the data was represented in JSON format with evidence of nested objects so that we could demonstrate the capabilities of MongoDB.\\
\linebreak
Here is a quick outline of how we processed the data to create JSON files:\\
Libraries used: ~Pandas~, ~PyArrow~, ~Faker~\\
\linebreak
~Pandas~ was used to load the csv files into dataframes where we merged data and applied ~group by~ aggregate functions to obtain lists of data objects per a unique entry id. This was useful, for example, when we obtained a list of tags per ~book_id~.\\
\linebreak
~Faker~ was used to generate random usernames for each id that were then written to ~user_data.csv~. The ~dataframes~ were then converted into JSON files.\\
\linebreak
All data pre-processing code is in the data-processing directory but the output JSON files are included in the final submission.

* Design a MongoDB Database
Both Collection Schemas were designed by creating hand-made JSON example objects. Each of these objects shows what a document in the DB would look like. Underneath each JSON example, we have included a diagram which represents the example's nesting visually.
** Collection 1 - ~books~

\paragraph{JSON example} \small
#+begin_src js
{
    "book_id": "98",
    "isbn": "1401359604",
    "isbn13": "9781401359610.0",
    "authors": [
        "Plum Sykes"
    ],
    "original_publication_year": 2004,
    "title": "Bergdorf Blondes",
    "language_code": "en-US",
    "average_rating": 3.26,
    "ratings_count": 23795,
    "total_ratings": {
        "ratings_1": 2020,
        "ratings_2": 4428,
        "ratings_3": 8669,
        "ratings_4": 6144,
        "ratings_5": 4561
    },
    "image_url": "https://s.gr-assets.com/assets/nophoto/book/111x148-bcc042a9c91a29c1d680899eff700a03.png",
    "tags": [
        {
            "tag_id": 11743,
            "tag_name": "fiction"
        },
        {
            "tag_id": 8717,
            "tag_name": "currently-reading"
        },
        {
            "tag_id": 8055,
            "tag_name": "contemporary"
        }
    ],
    "ratings": [
        {
            "user": {
                "user_id": 237,
                "user_name": "David Smith"
            },
            "rating": 1
        },
        {
            "user": {
                "user_id": 364,
                "user_name": "Christina Calderon"
            },
            "rating": 1
        },
        {
            "user": {
                "user_id": 399,
                "user_name": "Stephen Pugh"
            },
            "rating": 2
        }
    ]
}
#+end_src

\newgeometry{margin=0in}
#+ATTR_LATEX: :height 1.2\textwidth
[[file:Collection1Rotate.png]]
\restoregeometry
** Collection 2 - ~users~

#+begin_src js
{
    "user_id": 1,
    "user_name": "Mary Martinez",
    "ratings": [
        {
            "book": {
                "book_id": 47,
                "authors": [
                    "Markus Zusak"
                ],
                "title": "The Book Thief",
                "isbn": "375831002",
                "isbn13": 9780375831000.0,
                "language_code": "eng",
                "average_rating": 4.36,
                "ratings_count": 1159741,
                "image_url": "https://images.gr-assets.com/books/1390053681m/19063.jpg",
                "tags": [
                    {
                        "tag_id": 11557,
                        "tag_name": "favorites"
                    },
                    {
                        "tag_id": 30574,
                        "tag_name": "to-read"
                    },
                    {
                        "tag_id": 14487,
                        "tag_name": "historical-fiction"
                    },
                    {
                        "tag_id": 11743,
                        "tag_name": "fiction"
                    },
                    {
                        "tag_id": 33114,
                        "tag_name": "young-adult"
                    }
                ]
            },
            "rating": 3
        }
    ],
    "to_read": [
        {
            "book": {
                "book_id": 112,
                "authors": [
                    "Jojo Moyes"
                ],
                "title": "Me Before You",
                "isbn": "670026603",
                "isbn13": 9780670026610.0,
                "language_code": "eng",
                "average_rating": 4.27,
                "ratings_count": 587647,
                "image_url": "https://images.gr-assets.com/books/1357108762m/15507958.jpg",
                "tags": [
                    {
                        "tag_id": 30574,
                        "tag_name": "to-read"
                    },
                    {
                        "tag_id": 11557,
                        "tag_name": "favorites"
                    },
                    {
                        "tag_id": 17213,
                        "tag_name": "kindle"
                    },
                    {
                        "tag_id": 26138,
                        "tag_name": "romance"
                    },
                    {
                        "tag_id": 3389,
                        "tag_name": "audiobook"
                    }
                ]
            }
        }
    ]
}
#+end_src

\newgeometry{margin=0in}
#+ATTR_LATEX: :height 1.2\textwidth
[[file:Collection2Rotate.png]]
\restoregeometry

** Explanation and Justification
The data in CSV format emulates the functionality of a relational database. Many of the fields have foreign keys that point to elements in the other CSV files. Document store database favour efficiency over consistency, thus, we have nested a copy of the relevant object where the value would have otherwise been a foreign key. The process by how this was achieved was highlighted in "[[*Data Pre-Processing][Data Pre-Processing]]".

The data was seeded into the following 2 collections:
- ~books~
- ~users~\\
\linebreak
*** Books
The ~books~ collection roughly followed the format of ~books.csv~ (outlined in "[[*Data Set Explanation][Data Set Explanation]]") with some modifications. We omitted unnecessary information and altered the names of some of the properties to make their semantic meaning clearer. As a result each book document includes:
- General information about the book (~title~, ~author~, ~original_publication_year~, etc.).
- Aggregated rating values (~average_rating~, ~total_ratings~, ~ratings_counts~).
- A ~ratings~ list
  - Each element represents a ~user~'s review of that book. It includes the ~user~'s basic information and the assigned ~rating~ score.
- A ~tags~ list. Each tag represents a genre or category the book belongs to.\\
\linebreak
The most significant element of our design was the aforementioned nesting. Rather than store a separate ~tags~ collection, all the tags associated with the book are stored as a list of objects. The same is true for ~ratings~, which is a list of rating objects.\\
\linebreak
Use case examples:\\
- Collection of books: Querying to see the average rating of a book and the distribution of ratings of a particular book
*** Users
Unlike ~books~, the ~users~ collection does not directly correspond to a csv file. Instead, ~users~ was created by combining data from ~ratings.csv~, ~to_read.csv~, and ~books.csv~. We chose to create the user collection in order to demonstrate the importance of collection design with regards to query efficiency. While the ~users~ contains a lot of duplicate data from ~books~, it does so in a way that places information about the users at the top of the nesting hierarchy. This means that data about individual users can be obtained without performing expensive joins. The chosen collection design allows one to access, store and perform analytics from the perspective of the user. Each document in the ~users~ collection includes the following:
- A ~user_id~ and ~user_name~ (randomly generated, as explained in "[[*Data Pre-Processing][Data Pre-Processing]]").
- A ~ratings~ list:
  - Each element represents a score that the user has given to a book.
  - The element includes a ~book~ object and a given ~rating~ score.
  - The nested ~book~ object includes all high-level data about that book, as would be found in the ~books~ collection.
- A ~to_read~ list.
  - Each element represents a book that the user has added to their ~to_read~ list (ie. plans to read that book).
  - The element is represented as a ~book~ object that is identical in structure to those represented in the ~ratings~ list.\\
\linebreak
Use case examples:\\
        Collection of users: what books user X wants to read.

* Create and Load This MongoDB Database
** Load the Database
The process of creating and loading the database was significantly simplified on account of the fact that we had already [[*Data Pre-Processing][Pre-Processed]] the data into JSON format. For each collection, a shell command is called to seed the JSON data into their associated collections. The creation of the database is implicit ie. inserting data into the non-existent database leads to its creation. The commands use ~mongoimport~, a CLI tool designed for extracting data from plain-text formats (eg. JSON) and inserting them into MongoDB databases.

*** Books Collection
#+begin_src bash
mongoimport --db bookstore --collection books --file mongo-seed/books.json --jsonArray
#+end_src

*** Users Collection
#+begin_src bash
mongoimport --db bookstore --collection users --file mongo-seed/users.json --jsonArray
#+end_src

** Testing
The shell commands were tested and the output has been annotated on the following page:
\newgeometry{margin=0.1in}
#+ATTR_LATEX: :width 1\textwidth
[[file:q3.png]]
\restoregeometry

* Discuss the Relative Benefits and Disadvantages of MongoDB
** MongoDB (Document Store)
MongoDB is a document store database. Document store databases favour low retrieval latency and efficiency over consistency and functionality (expressiveness) when compared with relational databases. MongoDB is flexible: it facilitates incremental schema modification as the schema is not rigidly defined. This can improve development velocity and account for changing stakeholder requirements.\\
\linebreak
MongoDB is highly scalable and will be efficient with the ever increasing addition of books being published. MongoDB meets a good middle-ground when compared with other NoSQL databases. It is facilitates nested data and objects and allows querying on those objects without being overly strict or complex. Each Book and User is able to store all necessary information while allow for performant data retrieval without the overhead of complex joins.\\
\linebreak
The disadvantages of using a MongoDB are that there is a high degree of duplication and redundant data. This means that storing and transferring all of this data is computationally expensive. Secondly, inserting and updating data can be much more expensive than a relational database on account of the necessity to make updates in multiple places (due to the duplication). However, data about books is unlikely to change frequently (as the book has already been published) and thus this downside is heavily mitigated in the chosen example.

- *Benefits* (When compared with relational): Scalable, schema-free design, data-access performance
- *Disadvantages* (When compared with relational): Duplication, high storage use, slow modification, poor query expressiveness (functionality)
- *Role in polyglot persistence*:
  - A future polyglot design could store data that is high in volume but does not change frequently inside a document store db.
  - Books do not change frequently so the information about the books could be stored in the document store while users and ratings could be stored in other databases.
  - User telemetry could also be stored as in a document store database as it is high volume with very infrequent modification

** Graph DB
Graph databases allow for expressive and performant relationship representation and would be ideal for relationship-related queries. Each relationship can be given properties that qualitatively describe that relationship. This is ideal for data where the relationships to other data is the primary provider of utility (eg. a knowledge graph), as opposed to the structured categorisation (as is the case in MongoDB and relational databases).\\
\linebreak
The chosen dataset is highly structured without a large number of annotated relationships between data and it thus is a poor choice for graph DBs. The dataset would not leverage the benefits of a graph DB and would miss out on the well-fitted benefits of MongoDB, namely schema flexibility, performance, scalability, and simplicity.

- *Benefits*: Efficient modelling of highly inter-linked data, Query expressiveness (functionality), Great relationship representation (for which it is scalable and performant)
- *Disadvantages*: Unnecessary complexity, poor modelling of structured data
- *Role in polyglot persistence*:
  - A future polyglot design could include a graph database that models the relationship books have with each other.
  - Each book could have an outgoing edge to related books with a descriptive tag that describes their relationship strength and type.
  - This would prove highly useful for the site's recommendation engine.

** Key-value Store
Key-Value stores are extremely simple. They are very similar to a document store but with fewer capabilities in data representation and querying. They offer many of the same benefits of schema flexibility, scalability, and performance. Their key benefit and disadvantage over document stores is their simplicity. The simplicity is limiting but ideal for data that can be modelled simply. The chosen dataset is not suited for a key-value store as it includes more complex nested objects.
- *Benefits*: High performance, Scalability, Simplicity, Flexibility
- *Disadvantages*: Limited query capabilities and Does not support complex data structures.
- *Role in polyglot persistence*:
  - It can store the current session data of users. Easy to keep track of users' sessions such as how long they were on the app.
  - The key-value store's flexibility would be very important as it would allow us to store more complex session information about the user which can be used for processing later on to improve the user's experience on the application.

** Relational
Relational databases are great for keeping data consistent and for effectively maintaining the relationships of the data. Their ability to store relationships (via foreign keys) between data ensures the following benefits: data consistency, minimal duplication, and expressive queries. Relational databases falter when needing to retrieve large quantities of data from different tables. Joins become very expensive as the size of a dataset grows. Data analysis and operations are impacted substantially. It becomes inefficient with very large (big) data.\\
\linebreak
The goodbooks dataset at present would be well suited to a relational database, however, if we were to massively increase the scale of the data stored the efficiency gains of MongoDB would quickly become apparent. The data is not updated frequently enough for critical operations and thus the consistency benefits provided by a relational database would be negligible.

- *Benefits*: Query Expressiveness (functionality), consistency, reliability, low storage use (avoids duplication), accuracy, data integrity
- *Disadvantages*: Decrease in performance at scale, low flexibility (requires up-front schema design)
- *Role in polyglot persistence*:
  - A future polyglot design could include a relational database for data that would benefit from reliability and consistency.
  - Information about users, including their profiles, and security information could be stored in this format.
  - User data could benefit from the expressive queries provided by relational databases.

** Column Family
Column Family DBs are similar to relational databases, however, they bundle groups of frequently accessed columns together. This reduces the performance issues that may occur in relational databases. It does, however, still require up-front schema design without obtaining the expressiveness benefits provided by relational databases.\\
\linebreak

At present, the ~goodbooks~ database is not well suited to being effectively grouped. The only instance in which this would be useful would be a bundling of ratings data in the books table. However, the benefits are not extensive enough to utilise this over MongoDB for this dataset.

- *Benefits*: Compression of data, Scalable, fast to load queries, good for simple analytics.
- *Disadvantages*: Limited querying capabilities, limited data modelling capabilities
- *Role in polyglot persistence*:
  - A future polyglot design could include a column family for calculating metrics and performance analytics, such as:
    - How many books are users reading and the total number of stars people rated individual books
    - How long people stay on the website, etc.
  - Each set of metrics relating to a particular type of user data could be grouped into a column family for that user.

** Hierarchical
Hierarchical databases are optimised for data that can be stored as deeply nested hierarchies. Document Store DBs are also well suited for hierarchical nesting, however, their access performance greatly suffers when the depth of those hierarchies becomes excessive. Thus, hierarchical databases are great for data with inherently deep hierarchical structure. Hierarchical databases would be effective for fast lookup and to effectively store this data.\\
\linebreak
While the ~goodbooks~ dataset does include hierarchies, the hierarchies seldom extend beyond a depth of 5. This means the data is not inherently hierarchical and does not suffer from performance detriments when traversing the nested data. On account of this, a hierarchical database would be a poor choice as it would miss out on the key benefits of MongoDB (flexibility in particular).

- *Benefits*: Fast retrieval of nested data, efficient storage of data, predictable data structure
- *Disadvantages*: Limited flexibility, hard to maintain and update, limited interoperability, reduced expressiveness
- *Role in polyglot persistence*:
  - In the future, the platform may wish to hold a representation of books, their predecessors, and their successors.
  - A hierarchical relationship could be modelled such that each book belongs to a subgenre, which belongs to a series of parent genres. These books would have parent and descendant books that are influenced by them.
  - This hierarchy could be stored separately from the primary book database to avoid affecting its performance and size.

* Query and Updating the Database
** GRDDAN017
*** 1
*Description*\\
Find the book title and author list of the top 3 highest rated books.\\
\linebreak
*Query*
#+begin_src js
db.books.find({},{
    _id: false, book_id: true, title: true, authors: true, average_rating: true
}).sort({average_rating:-1}).limit(3);
#+end_src
\linebreak
*Output*\\
#+ATTR_LATEX: :width 1\textwidth
[[file:images/GRDDAN017/1.png]]
\pagebreak
*** 2
*Description*\\
Find 2 books with the "fantasy" tag with a high average rating.\\
\linebreak
*Query*
#+begin_src js
db.books.find({
    $and: [{ "tags.tag_name": "fantasy" }, { "average_rating": { $gt: 4 } }]
}).limit(2)
#+end_src
\linebreak
*Output*\\
#+ATTR_LATEX: :width 1\textwidth
[[file:images/GRDDAN017/2.png]]
\pagebreak
*** 3
*Description*\\
Find users who have rated a book but have an empty to_read list.\\
\linebreak
*Query*
#+begin_src js
db.users.find({
    ratings: { $exists: true, $not: {$size: 0} },
    to_read: { $size: 0 }
}, {
    _id: false, ratings: false
});
#+end_src
\linebreak
*Output*\\
#+ATTR_LATEX: :width 1\textwidth
[[file:images/GRDDAN017/3.png]]
\pagebreak
*** 4
*Description*\\
Add a book to a user's to-read list.\\
\linebreak
*Query*
#+begin_src js
db.users.updateOne({
    "user_id"   : 4
}, {
    $push: {
        "to_read": {
            book: { book_id: 0, authors: ["Daniel Gordon"], title: My Story,
                    isbn: "0", isbn13: 0, average_rating: -1, tags: ["trash"]}
        }
    }
})
#+end_src

\linebreak
*Output*\\
#+ATTR_LATEX: :width 1\textwidth
[[file:images/GRDDAN017/4.png]]
\pagebreak
** MRCGAB004
*** 1
*Description*\\
Find and return a list of users’ names  who want to read “The book Thief”.\\
\linebreak
*Query*
#+begin_src js
db.users.find( {
    "to_read.book.title":"The Book Thief"
}, {
    "_id":0,"user_name":1
})
#+end_src
\linebreak
*Output*\\
#+ATTR_LATEX: :width 1\textwidth
[[file:images/MRCGAB004/1.png]]
\pagebreak
*** 2
*Description*\\
Find a list of books published after 2004 and return the title and year it was published.\\
\linebreak
*Query*
#+begin_src js
db.books.find({
    "original_publication_year":{ "$gt": 2004 }
},{
    "title":1, "_id":0,"original_publication_year":1
})
#+end_src
\linebreak
*Output*\\
#+ATTR_LATEX: :width 1\textwidth
[[file:images/MRCGAB004/2.png]]
\pagebreak
*** 3
*Description*\\
Update the book “Bergdorf Blondes” with a new publishing date of 2005 db.books.updateOne. \\
\linebreak
*Query*
#+begin_src js
db.books.updateOne({
    "title":"Bergdorf Blondes"
},{
    "$set":{"original_publication_year":2005}
})
#+end_src

#+RESULTS:

\linebreak
*Output*\\
#+ATTR_LATEX: :width 1\textwidth
[[file:images/MRCGAB004/3.png]]
\pagebreak
*** 4
*Description*\\
Delete user with the user_id 32.\\
\linebreak
*Query*
#+begin_src js
db.users.deleteOne({"user_id":32})
#+end_src

\linebreak
*Output*\\
#+ATTR_LATEX: :width 1\textwidth
[[file:images/MRCGAB004/4.png]]
\pagebreak
** CRGMAT002
*** 1
*Description*\\
Find the top 5 books (by average_rating) with tag_name "sci-fi". Show only a single author for each book. \\
\linebreak
*Query*
#+begin_src js
db.books.find({
    tags: {$elemMatch: {tag_name: "sci-fi"}}
}, {
    _id: 0, title: 1, authors: {$slice: 1}, average_rating: 1,
}).sort({average_rating : -1 }).limit(5)
#+end_src
\linebreak
*Output*\\
#+ATTR_LATEX: :width 1\textwidth
[[file:images/CRGMAT002/1.png]]
\pagebreak
*** 2
*Description*\\
Aggregate user_ids alongside the total number of ratings that user has submitted (size of ratings array). The result is sorted by the number of ratings they have submitted and the top 10 are shown. \\
\linebreak
*Query*
#+begin_src js
db.users.aggregate([ {
    $project: {_id: 0, user_id: 1, numRatings: { $size: "$ratings" }}
}, {
    $sort: { numRatings: -1 }
}, {
    $limit: 10
}])
#+end_src
\linebreak
*Output*\\
#+ATTR_LATEX: :width 1\textwidth
[[file:images/CRGMAT002/2.png]]
\pagebreak
*** 3
*Description*\\
Update a user that has rated "The Book Thief" with 4 stars. Change their name to: ~"Update_User!"~\\
\linebreak
*Query*
#+begin_src js
db.users.updateOne({
    "ratings": {$elemMatch: {rating: 4, "book.title": "The Book Thief"}}
},{
    $set: {user_name: "Update_Username!"}
})
#+end_src
\linebreak
*Output*\\
#+ATTR_LATEX: :width 1\textwidth
[[file:images/CRGMAT002/3.png]]
\pagebreak
*** 4
*Description*\\
test\\
\linebreak
*Query*
#+begin_src js
db.books.deleteMany({
    authors: "Roald Dahl"
},{
    title: 1
})
#+end_src

\linebreak
*Output*\\
#+ATTR_LATEX: :width 1\textwidth
[[file:images/CRGMAT002/4.png]]
\pagebreak
** WHLJOS001
*** 1
*Description*\\
Find the names and ratings of the top 50 fiction books with at least 1000 ratings. The result would be too large to show in a single screen but several are shown in the image below.
\\
\linebreak
*Query*
#+begin_src js
db.books.aggregate([{
    $match: { "total_ratings": { $gte: 1000 }, "tags.tag_name": "fiction" }
}, {
    $sort: { "average_rating": -1 }
}, {
    $limit: 50
}, {
    $project: { _id: 0, title: 1, average_rating: 1 }
}] )
#+end_src
\linebreak
*Output*\\
#+ATTR_LATEX: :width 1\textwidth
[[file:images/WHLJOS001/1.png]]
\pagebreak
*** 2
*Description*\\
Delete all users who have never rated a book and never marked a book as ~to_read~. Since this database has only a subset of the full dataset it seems that no users were found to both not have rated or marked a book as to read, so no data was deleted.
\\
\linebreak
*Query*
#+begin_src js
db.users.deleteMany({
    $and: [{to_read: { $exists: false }},
           {ratings: { $exists: false }}]
})
#+end_src

#+RESULTS:

\linebreak
*Output*\\
#+ATTR_LATEX: :width 1\textwidth
[[file:images/WHLJOS001/2.png]]
\pagebreak
*** 3
*Description*\\
Delete all books with an average rating less than 2 and more than 300 ratings. Similar to the previous query, since this is only a select subset of the dataset no books were found that matched the query. So no books were deleted in this case.\\
\linebreak
*Query*
#+begin_src js
db.books.deleteMany({
    $and: [ {
        "average_rating": { $lt: 2 }
    }, {
        "total_ratings": { $gt: 300 }
    }]
})
#+end_src
\linebreak
*Output*\\

#+ATTR_LATEX: :width 1\textwidth
[[file:images/WHLJOS001/3.png]]
\pagebreak
*** 4
*Description*\\
Find the name of the user who has rated the most books.\\
\linebreak
*Query*
#+begin_src js
db.users.aggregate({
    $project: { user_id: 1, user_name: 1, num_ratings: { $size: "$ratings" } }
},{
    $sort: { num_ratings: -1 }
},{
    $limit: 1
}, {
    $project: {
        _id: 0, user_name: 1
    }
})
#+end_src

\linebreak
*Output*\\
#+ATTR_LATEX: :width 1\textwidth
[[file:images/WHLJOS001/4.png]]
\pagebreak
** KFWJOR001
*** 1
*Description*\\
Finding users who have rated the most diverse genres
\linebreak
*Query*
#+begin_src js
db.users.aggregate([
    { $unwind: "$ratings" },
    { $lookup: {
        from: "books",
        localField: "ratings.book.title", foreignField: "title",
        as: "rated_books" } },
    { $unwind: "$rated_books" },
    { $unwind: "$rated_books.tags" },
    { $group: { _id: "$user_id", user_name: { $first: "$user_name" },
                genres: { $addToSet: "$rated_books.tags.tag_name" } } },
    { $addFields: { num_genres: { $size: "$genres" } } },
    { $sort: { num_genres: -1 } },
    { $limit: 10 }
])
#+end_src

#+RESULTS:

\linebreak
*Output*\\
#+ATTR_LATEX: :width 1\textwidth
[[file:images/KFWJOR001/1.png]]
\pagebreak
*** 2
*Description*\\
Find highly rated books and only show their title, authors and average rating
\\
\linebreak
*Query*
#+begin_src js
db.books.find({ "average_rating": { $gte: 4.5 } }, {title: 1, authors:1, average_rating: 1})
#+end_src

#+RESULTS:

\linebreak
*Output*\\
#+ATTR_LATEX: :width 1\textwidth
[[file:images/KFWJOR001/2.png]]
\pagebreak

*** 3
*Description*\\
Give all books published before 2010 the “classic” tag\\
\linebreak
*Query*
#+begin_src js
db.books.updateMany( {
    "original_publication_year": { $lt: 2010 } }, {
        $addToSet: { "tags": {tag_id: 12345, tag_name: "classic"} } }
#+end_src
\linebreak
*Output*\\

-  3 - Query
#+ATTR_LATEX: :width 1\textwidth
[[file:images/KFWJOR001/3-query.png]]

-  3 - Before
#+ATTR_LATEX: :width 1\textwidth
[[file:images/KFWJOR001/3-before.png]]

-  3 - After
#+ATTR_LATEX: :width 1\textwidth
[[file:images/KFWJOR001/3-after.png]]
\pagebreak
*** 4
*Description*\\
Updates all books authored by J.K. Rowling (all Harry Potter) by removing the incorrect author “Mary Grandpr" while also removing any ratings below 5 stars for those books\\
\linebreak
*Query*
#+begin_src js
db.books.updateMany(
    { "authors": "JK Rowling" },
    {
        $set: { "authors": ["JK Rowling"] },
        $pull: { "ratings": { "rating": { $lt: 5 } } }
    }
);
#+end_src

\linebreak
*Output*\\

-  4 - Query
#+ATTR_LATEX: :width 1\textwidth
[[file:images/KFWJOR001/4-query.png]]

-  4 - Before Ratings
#+ATTR_LATEX: :width 1\textwidth
[[file:images/KFWJOR001/4-before-ratings.png]]

-  4 - After Ratings
#+ATTR_LATEX: :width 1\textwidth
[[file:images/KFWJOR001/4-after-ratings.png]]

-  4 - Before Books
#+ATTR_LATEX: :width 1\textwidth
[[file:images/KFWJOR001/4-before-books.png]]

-  4 - After Books
#+ATTR_LATEX: :width 1\textwidth
[[file:images/KFWJOR001/4-after-books.png]]

* Link the Database to a Program
Instructions for running the program can be found in ~README.md~.

* Contribution Statement
|-------------------------------+-------------------------|
| Task                          | Who did it              |
| Design Schema/JSON            | Matthew & Gabe          |
| Setup Devops (Github, Docker) | Jordy                   |
| Preprocessing                 | Joe & Daniel            |
| Create the App                | Jordy                   |
| Query                         | Everyone                |
| Load into mongodb             | Mathew                  |
| Write Up                      | Gabe & Matthew & Daniel |
|-------------------------------+-------------------------|
